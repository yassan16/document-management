# ドメイン駆動設計 Domain-Driven Design （DDD）
業務領域（ドメイン）を中心に据えた設計手法。  
以降は、「DDD」と呼称する。

## DDDの目的
* 機能性を高める
  * 役立つものを作る
  * 「作ったけど使えない」を避ける
* 保守性を高める
  * 長期間開発しても、機能拡張が容易
  * 「技術的負債でどんどん開発速度が低下する」を避ける

## 目的を達成するためのアプローチ
* 機能性を高める
  * ドメインモデリング
* 保守性を高める
  * モデルをそのまま表現する実装
  * エンティティ、リポジトリなどの実装パターン
* DDDの特徴
  * 「ドメインモデル」を使って両方のアプローチがリンクすること
  * 片方ずつでも効果が出るが、両方使うと大きな相乗効果が出る

## ドメインモデリングってどうやるのか？
特に１つこの手法があると決まってるわけではない。  
数ある中でおすすめなのが、「sudoモデリング」である。  

## sudoモデリング
sudoモデリングでは、4つのモデル図を作成する。
* システム関連図(s)
* ユースケース図(u)
* ドメインモデル図(d)
* オブジェクト図(o)

### ◽️システム関連図
開発するシステムと関わりのあるactorや外部システムとの関連を示す図。  
この図を作成することで、「誰が使用するシステムなのか？」を明確にする。

#### 題材
人事などの採用担当者が企業への応募者を管理する、採用管理システムとする。  
以下のsudoモデリングでの説明でも、この内容を使用する。

##### actor
* 応募者
  * 採用ページからリンクを飛んで、フォームで応募する
* 採用担当者

##### システム
* 応募フォーム
  * 応募者が使用する
  * 採用管理システムへ応募フォームからの自動連携は、最初は行わない  
    直接、採用管理システムに手入力
* 採用管理システム（今回開発するシステム）
  * 採用担当者が操作する
  * 応募者が直接、このシステムに登録しない
  * メール送信リクエストを、メール送信システムに送る
* メール送信システム
  * メール送信は外部のマネージドサービスを使用する

### ◽️ユースケース図
ユーザの要求に対してシステムの振る舞いを定義する図。
この後にドメインモデル図を作成するため、どのようなユースケースを抑えるべきを観点として作る。  
以降のドメインでのスコープを明確にする。

#### 例
採用担当者が、以下のことを実行できる。
##### 採用管理システム
* 採用選考を登録する
* 面接を設定する
##### 外部連携
* 候補者にメールを送信する

### ◽️ドメインモデル図・オブジェクト図
ドメインモデル図とは、簡易化したクラス図のようなもの。  
次のようなルールで記載する。
* オブジェクトの代表的な属性を書くが、メソッドは書かなくてよい
* 「ルール/制約(ドメイン知識)」を吹き出しに書き出す
* オブジェクト同士の関連を示す
* 集約の範囲を定義する
* 日本語と英語の対訳を定義する  

最終的に、まとめた内容がクラスになる。

#### 書き方
1. まず具体例を元に、オブジェクト図を作る  
2. 抽象化して、ドメインモデル図を作る

#### ドメイン知識
* 最終的にエンティティ/値オブジェクトとなるオブジェクト、それに関わるルール/制約(ドメイン知識)を記載する
* 検討メモ：図を作成する際に生じた疑問は、その場で議論して決定した内容を記載する  
  未決定事項や今後の展開も同様にメモする

#### 多重度
* 「採用選考から採用ボジションを紐づけることは必須なのか？」といったことは、ルール/制約として大事な意思決定となる

#### 集約
「リポジトリに入出力する範囲」のこと  
「エンティティ」や「値オブジェクト」を個別に扱うのではなく、「意味のある単位」でグループ化し、一貫した操作を保証することが役割

##### 集約を構成する要素
* エンティティ
* 値オブジェクト
* 集約ルート（Aggregate Root）
  * 集約全体を代表するエンティティ
  * 外部からは必ず集約ルートを経由して、データを変更する
  * 例：「注文（Order）」の中に「注文明細（OrderItem）」がある場合、注文が集約ルートになる

##### なぜ集約が必要か？
データを単純にエンティティや値オブジェクトとして設計すると、以下の問題が発生する可能性がある
1.	整合性の維持が難しい  
  例: 注文の支払いが完了しているのに、注文明細が不整合な状態で変更される  
  ➡ 集約単位で変更を制限し、一貫性を守る
2.	不適切なデータ操作が発生しやすい  
  例: 直接「注文明細（OrderItem）」を変更してしまうと、「注文（Order）」との整合性が崩れる  
  ➡ 集約ルートを通じてのみ操作を許可
3.	トランザクションの管理が困難  
  例: 1つの注文に複数の商品がある場合、注文全体が一貫した状態で処理される必要がある  
  ➡ 1つの集約単位でトランザクションを管理する

##### 集約の設計指針
集約の設計ルール  
1.	集約ルート以外のエンティティには直接アクセスしない  
  ❌ NG: OrderItem を直接更新  
  ✅ OK: Order を通じて OrderItem を変更
2.	集約はトランザクションの境界とする  
  1つの集約に対する変更は、1回のトランザクション内で完結させる
3.	小さな集約にする  
  集約を大きくしすぎると性能が低下する（大規模なデータ読み込みが発生するため）  
  例: User に Order を含めるのではなく、別の集約として管理する

#### 集約の範囲
* オブジェクト、ルール/制約がある程度できたら、集約の範囲を決定する
* リポジトリは集約に対して１つ作るので、集約の範囲が決まるとエンティティ、値オブジェクト、リポジトリがどういう形で実装されるか決まる
* ただし集約の良し悪しは、実装してみないとわからないことが多い  
  実装して問題があれば、ドメインモデル図に戻って更新する

#### 日本語名の対訳としての英語名
* ここで英語名を決めることで、以降のエンドポイント名、テーブル名、クラス名などで使用される英語の表記揺れを防げる

## 参考サイト
* [さようなら軽量DDD。10分でわかるドメインモデリング - ドメイン駆動設計](https://www.youtube.com/watch?v=HgtCKlOzRiQ&list=PLXMIJq1G-_66F9woQpidJfe4HHCFxdXaA&index=1)
* [Flutterのアーキテクチャ、プロジェクト構成、フォルダ構成はどうすればいいのか](https://qiita.com/MLLB/items/95617322a7d984b7e402)
* [バックエンドエンジニアたちが複数のFlutterアプリを並行開発していく中で見つけたベストプラクティス](https://blog.kinto-technologies.com/posts/2023-12-10-flutter-architecture/)
* [Flutter App Architecture with Riverpod: An Introduction](https://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/)
